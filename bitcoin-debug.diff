diff --git a/src/secp256k1/src/modules/schnorrsig/main_impl.h b/src/secp256k1/src/modules/schnorrsig/main_impl.h
index 22e1b33a5..7e920cc36 100644
--- a/src/secp256k1/src/modules/schnorrsig/main_impl.h
+++ b/src/secp256k1/src/modules/schnorrsig/main_impl.h
@@ -11,6 +11,16 @@
 #include "include/secp256k1_schnorrsig.h"
 #include "hash.h"
 
+static void print32(const char* tag, const unsigned char* buf32) {
+    int i = 0;
+
+    printf("%s ", tag);
+    for (i = 0; i < 32; i++) {
+        printf("%02x", buf32[i]);
+    }
+    printf("\n");
+}
+
 /* Initializes SHA256 with fixed midstate. This midstate was computed by applying
  * SHA256 to SHA256("BIP0340/nonce")||SHA256("BIP0340/nonce"). */
 static void secp256k1_nonce_function_bip340_sha256_tagged(secp256k1_sha256 *sha) {
@@ -113,6 +123,10 @@ static void secp256k1_schnorrsig_challenge(secp256k1_scalar* e, const unsigned c
     unsigned char buf[32];
     secp256k1_sha256 sha;
 
+    print32("C challenge R32     ", r32);
+    print32("C challenge PUBKEY32", pubkey32);
+    print32("C challenge MSG32   ", msg32);
+
     /* tagged hash(r.x, pk.x, msg32) */
     secp256k1_schnorrsig_sha256_tagged(&sha);
     secp256k1_sha256_write(&sha, r32, 32);
@@ -204,15 +218,18 @@ int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const unsigned cha
     ARG_CHECK(msg32 != NULL);
     ARG_CHECK(pubkey != NULL);
 
+    printf("if (!secp256k1_fe_set_b32(&rx, &sig64[0]))\n");
     if (!secp256k1_fe_set_b32(&rx, &sig64[0])) {
         return 0;
     }
 
+    printf("secp256k1_scalar_set_b32(&s, &sig64[32], &overflow);\n");
     secp256k1_scalar_set_b32(&s, &sig64[32], &overflow);
     if (overflow) {
         return 0;
     }
 
+    printf("if (!secp256k1_xonly_pubkey_load(ctx, &pk, pubkey))\n");
     if (!secp256k1_xonly_pubkey_load(ctx, &pk, pubkey)) {
         return 0;
     }
@@ -221,17 +238,37 @@ int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const unsigned cha
     secp256k1_fe_get_b32(buf, &pk.x);
     secp256k1_schnorrsig_challenge(&e, &sig64[0], msg32, buf);
 
+    print32("C verify XPUBKEY  ", buf);
+    print32("C verify MSG32    ", msg32);
+
+    {
+        unsigned char ebuf[32];
+        secp256k1_scalar_get_b32(ebuf, &e);
+        print32("C verify CHALLENGE", ebuf);
+    }
+    
     /* Compute rj =  s*G + (-e)*pkj */
     secp256k1_scalar_negate(&e, &e);
     secp256k1_gej_set_ge(&pkj, &pk);
     secp256k1_ecmult(&ctx->ecmult_ctx, &rj, &pkj, &e, &s);
 
     secp256k1_ge_set_gej_var(&r, &rj);
+
+    printf("if (secp256k1_ge_is_infinity(&r)) \n");
     if (secp256k1_ge_is_infinity(&r)) {
         return 0;
     }
 
     secp256k1_fe_normalize_var(&r.y);
+
+    printf("return !secp256k1_fe_is_odd(&r.y)\n");
+    {
+        int ryisodd = secp256k1_fe_is_odd(&r.y);
+        int rxeqrdx = secp256k1_fe_equal_var(&rx, &r.x);
+        printf("ryisodd %d\n", ryisodd);
+        printf("rxeqrdx %d\n", rxeqrdx);
+    }
+    
     return !secp256k1_fe_is_odd(&r.y) &&
            secp256k1_fe_equal_var(&rx, &r.x);
 }
